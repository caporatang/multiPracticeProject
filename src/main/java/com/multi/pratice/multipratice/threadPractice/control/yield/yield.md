# yield
스레드 실행 순서에 대한 양보(?)를 할 수 있는 방법은 멀티 스레드 상태에서 sleep으로 매번 다른 스레드들을 WAITING 시키거나 yield를 사용하면 된다.  

- sleep()  
상태는 Runnable로 유지된다. CPU에서 실행 해야되는데 양보하고 다시 대기큐로 돌아간다.
결과적으로 TIMED_WAITING 상태가 되면서 다른 스레드에 실행을 양보하고 대기큐로 간다는것이다.
하지만, 이러한 방식은 RUNNABLE -> TIMED_WAITING -> RUNNABLE로 변경되는 과정이 필요하고 또 특정 시간만큼 스레드가 실행되지 않는 단점이 있다.
예를 들어, 양보할 스레드가 없으면 차라리 나의 스레드를 더 실행하는 방법이 더 나을 수 있다. -> 양보할 사람이 없는데 자리를 양보한다? 말이 안된다.  
  

- sleep의 단점을 보완하기 위한 **yield**  
자바의 스레드가 Runnable 상태일 때, 운영체제의 스케줄링은 다음과 같은 상태들을 가질 수 있다.
  - 실행 상태 (Running) : 스레드가 CPU에서 실제로 실행 중이다.
  - 실행 대기 상태 (Ready) : 스레드가 실행될 준비가 되었지만, CPU가 바빠 스케줄링 큐에서 대기 중이다.  

운영체제는 실행 상태의 스레드들을 잠깐만 실행하고 실행 대기 상태로 만든다. 그리고 실행 대기 상태의 스레드들을 잠깐만 실행 상태로 변경해서 실행한다.
이 과정을 계속 반복하고 자바에서는 두 상태를 따로 구분하지 않는다.

## yield() 의 작동
yield 메서드는 현재 실행 중인 스레드가 자발적으로 CPU를 양보하여 다른 스레드가 실행될 수 있도록 한다. yield 메서드를 호출한 스레드는 RUNNABLE 상태를 유지하면서 CPU를 양보한다. 즉, 스레드는 다시 스케줄링 큐에 들어가면서 다른 스레드에게 CPU 사용 기회를 넘겨준다.

yield() 메서드를 호출하면 현재 실행 중인 스레드가 CPU를 양보하도록 힌트를 준다. 이는 스레드가 자신에게 할당된 실행 시간을 포기하고 다른 스레드에게 실행 기회를 주도록하며 yield는 운영체제의 스케줄러에게 단지 힌트를 제공할 뿐, 강제적인 실행 순서를 지정하지 않고 yield 메서드를 사용한다고 해서 반드시 다른 스레드가 실행 되는 것도 아니다.  
yield 메서드를 사용해도 해당 스레드의 상태는 RUNNABLE이 유지되기 때문에, 양보할 스레드가 없다면 해당 스레드가 계속 실행한다.


