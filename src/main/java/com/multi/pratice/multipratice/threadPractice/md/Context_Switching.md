# Context Switching
멀티태스킹이 반드시 효율적인 것은 아니다.  
CPU 코어가 하나, 스레드는 A와 B가 있다. 운영체제가 먼저 스레드A를 실행한다. 운영체제는 멀티태스킹을 해야하 하기 때문에 스레드A를 잠시 멈추고 스레드B를 실행한다. 그 후 다시 스레드 A를 실행하려고 한다면 운영체제는 스레드A의 코드가 어디까지 수행되었는지 위치를 찾아야 한다. 그리고 계산하던 변수들의 값을 CPU에 다시 불러들여야 한다.  
따라서 스레드A를 멈추는 시점에 CPU에서 사용하던 이런 값들을 메모리에 저장해두고, 스레드A를 다시 실행할 때 이 값들을 CPU에 다시 불러와야 한다.  
이러한 과정을 Context Switching이라 한다. 결과적으로 컨텍스트 스위칭 과정에서 이전에 실행 중인 값을 메모리에 잠깐 저장하고, 다시 실행하는 시점에 저장한 값을 CPU에 다시 불러와야 해서 약간의 비용이 발생한다.  

## CPU 바운드 작업 vs I/O 바운드 작업
각각의 스레드가 하는 작업은 크게 2가지로 나뉜다.
- CPU-바운드 작업 (CPU-bound tasks)
  - CPU의 연산 능력을 많이 요구하는 작업을 의미한다.
  - 이러한 작업은 주로 계산, 데이터 처리, 알고리즘 실행 등 CPU의 처리 속도가 작업 완료 시간을 결정하는 경우다.
    - ex) 복잡한 수학 연산, 데이터 분석, 비디오 인코딩
- I/O 바운드 작업 (I/O-bound tasks)
  - 디스크, 네트워크, 파일 시스템 등과 같은 입출력 작업을 많이 요구하는 작업을 의미한다.
  - 이러한 작업은 I/O 작업이 완료될 때까지 대기 시간이 많이 발생하며, CPU는 상대적으로 유휴(대기) 상태에 있는 경우가 많다. 쉽게 이야기해서 스레드가 CPU를 사용하지 않고 I/O 작업이 완료될 때 까지 대기한다.
    - ex) 데이터베이스 쿼리 처리, 파일 읽기/쓰기, 네트워크 통신, 사용자 입력 처리 등....

## 웹 어플리케이션 서버인 경우 ?
실무에서는 CPU-바운드 작업 보다는 I/O-바운드 작업이 많다.
백엔드 개발자의 경우 주로 웹 어플리케이션 서버를 개발하는데, 스레드가 1- 10000 까지 더하는 CPU 연산이 필요한 작업보다, 대부분 사용자의 입력을 기다리거나 데이터베이스 호출 등.. 기다리는 일이 많다. 스레드가 CPU를 많이 사용하지 않는 I/O-바운드 작업이 많다는 뜻이다.

정리하자면 스레드의 숫자는 CPU-바운드 작업이 많은가, 아니면 I/O-바운드 작업이 많은가에 따라 다르게 설정해야 한다.
- CPU-바운드 작업 : CPU 코어 수 + 1개
  - CPU를 거의 100% 사용하는 작업이므로 스레드를 CPU 숫자에 최적화
- I/O 바운드 작업 : CPU 코어 수 보다 많은 스레드를 생성, CPU를 최대한 사용할 수 있는 숫자까지 스레드를 생성
  - CPU를 많이 사용하지 않으므로 성능 테스트를 통해 CPU를 최대한 활용하는 숫자까지 스레드를 생성한다.
  - 단, 너무 많은 스레드를 생성하면 컨텍스트 스위칭 비용도 함께 증가하므로 성능 테스트는 꼭 진행해야 한다.


